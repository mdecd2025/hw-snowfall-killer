<h1>About</h1>
<p>41023218</p>
<p>課程名稱: 協同產品設計實習 - Collaborative Product Design Practice</p>
<p>學員作業網站：<a href="https://mdecd2025.github.io/hw-snowfall-killer/content/index.html" target="_blank">https://mdecd2025.github.io/hw-snowfall-killer/content/index.html</a></p>
<p>學員作業倉儲：<a href="https://github.com/mdecd2025/hw-snowfall-killer" target="_blank">https://github.com/mdecd2025/hw-snowfall-killer</a></p>
<hr/>
<p>課程代號: cd2025</p>
<p>Teams 線上教學:</p>
<p style="padding-left: 30px;">以 "學號@nfu.edu.tw" 登入<span> </span><a href="https://login.microsoftonline.com/">https://login.microsoftonline.com/</a><span> </span>Office 365</p>
<p style="padding-left: 30px;">Teams 團隊代碼: <span>p5z4eku</span></p>
<hr/>
<p>課程評分:</p>
<p style="padding-left: 30px;">Homework (30%) - 每週至少提交兩次與課程進度有關的內容, 完成後填回自評表單</p>
<p style="padding-left: 30px;">Exam (40%) - 建立包含操作流程影片、心得以及提供檔案下載的網頁後填回自評表單</p>
<p style="padding-left: 30px;">Final Report (30%) - 利用網頁內容進行簡報並提交 pdf 格式書面報告, 完成後填回自評表單</p>
<p></p>
<h1>Task</h1>
<p>task1 與 task2 任務目的在建立可於近端維護個人作業與協同作業的準備工作:</p>
<p style="padding-left: 30px;">task1 (自行製作可攜程式系統)</p>
<p style="padding-left: 30px;">task2 (使用 SSH 協定執行作業倉儲的推送)</p>
<p>task3 與 task4 則為 HW2 的內容之一</p>
<p style="padding-left: 30px;">task3 (使用 Solvespace 建立平面四連桿系統零組件)</p>
<p style="padding-left: 30px;">task4 (使用 Onshape 建立平面四連桿系統零組件)</p>
<p>task5 與 task6 則為 HW3 的主要內容</p>
<p style="padding-left: 30px;">task5 (Webots Tutorial 1 ~3)</p>
<p style="padding-left: 30px;">task6 (Webots Tutorial 4 ~6)</p><h2>Task1</h2>
<h4>自行製作可攜程式系統</h4>
<p>此作業的目的在展示如何利用既有的 Python 可攜系統建立各版本的 Python 可攜環境.</p>
<p>以下為操作步驟:</p>
<ol>
<li>下載<span> </span><a href="http://229.cycu.org/portable_python311.7z">portable_python311.7z</a>, 展開後是一套尚未安裝 pip 的 Python 3.11 可攜程式環境.</li>
<li>雙點擊 portable_python311 目錄中的 start_ipv6.bat 啟動可攜系統, 在 SciTE 中開啟 Y:\<a href="https://mdecd2025.github.io/hw-scrum-1/downloads/gen_python313.py">gen_python313.py</a>, 以下拉式功能表 Tools - Go 執行, 便可在 Y:\ 建立 Python313 目錄.</li>
<li>接著修改 start_ipv6.bat, 利用 Search - Replace, Find 欄位填上 Python311, Replace 欄位填上 Python313 後, 按下 Replace All, 便可將啟動檔中所有 Python311 設定改為 Python313, 另存修改後的檔案為 start_python313.bat.</li>
<li>接下來以 stop.bat 關閉 start_ipv6.bat 開啟的可攜系統, 改以心建立的 start_python313.bat 開啟可攜環境, 之後在命令列輸入 python, 確認目前的 Python 版本為 3.13.2 後, 利用 Ctrl + z 退出 Python 後, 利用 pip list 確認目前的 Python 3.13.2 系統尚未配置 pip 模組管理工具.</li>
<li>在命令列中, 以 python get-pip.py 安裝 pip 工具, 完成後, 以 pip list 確認 pip.exe 已經配置完成.</li>
<li>最後在命令列中, 以 pip install flask flask_cors bs4 lxml pelican markdown 安裝 cmsimde 網際內容管理系統啟動所需的 Python 模組後, 此可攜系統中的 Python 3.13.2 套件已經可以用來維護個人作業倉儲與分組倉儲.</li>
<li>之後利用新版的<span> </span><a href="https://www.scintilla.org/SciTEDownload.html">SciTE</a>,<span> </span><a href="https://git-scm.com/downloads/win">Portablegit</a>,<span> </span><a href="https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html">PUTTY</a>,<span> </span><a href="https://github.com/ShareX/ShareX/releases">ShareX</a>,<span> </span><a href="https://www.debugmode.com/wink.html">Wink</a>,<span> </span><a href="https://solvespace.com/download.pl">Solvespace</a>,<span> </span><a href="https://learn.microsoft.com/zh-tw/sysinternals/downloads/zoomit">Zoomit</a>,<span> </span><a href="https://learn.microsoft.com/zh-tw/sysinternals/downloads/process-explorer#download">ProcessExplorer</a><span> </span>以及原有的 tmp 及 home_ipv6, 以新的 start_python313 啟動.</li>
</ol>
<p>以下為操作影片:</p>
<h3>list</h3>
<p><button id="cd2025students">cd2025students</button><button id="cd2025sap">cd2025sap</button></p>
<!-- 導入 brython 程式庫 -->
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫 -->
<script src="/static/Cango-24v03-min.js"></script>
<script src="/static/gearUtils-09.js"></script>
<script src="/static/SVGpathUtils-6v03-min.js"></script>
<script src="/static/sylvester.js"></script>
<script src="/static/PrairieDraw.js"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()
Ace1 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run1():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/snowfall-killer/61fa9780a59be3e44f8653f0a66e49dc/raw/1b1c9b3407a46b492ecc1986905cc43562c0ad66/cd2025_student.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace1.editor.setValue(prog)
    Ace1.editor.scrollToRow(0)
    Ace1.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace1.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run1'].bind('click', Ace1.run)
doc['kw_show_console1'].bind('click', Ace1.show_console)
doc['kw_clear_console1'].bind('click', Ace1.clear_console)
doc['clear_bd1'].bind('click', clear_bd1)
# 呼叫函式執行
run1()
</script>
</p>
<p><!-- cd2025students 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

# 透過 Ace2 以類別建立一個通用的 button2, 可以在多個案例中將 gist 程導入編輯區

class button2:
    def __init__(self, url):
        self.url = url

    # 記得加入 event 輸入變數
    def do(self,ev):
        Ace2.editor.setValue(open(self.url).read())
        Ace2.editor.scrollToRow(0)
        Ace2.editor.gotoLine(0)
        Ace2.run()

cd2025students_url = "https://gist.githubusercontent.com/snowfall-killer/61fa9780a59be3e44f8653f0a66e49dc/raw/1b1c9b3407a46b492ecc1986905cc43562c0ad66/cd2025_student.py"

# 從 gist 取得程式碼
add_src = open(cd2025students_url).read()
def add(ev):
    Ace2.editor.setValue(add_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "cd2025students" 的按鈕點按時, 執行 add 方法
doc["cd2025students"].bind('click', add)
# 以下為運用 button2 class 的通用 gist 程式導入區
################################## cd2025students start
cd2025students_url = "https://gist.githubusercontent.com/snowfall-killer/61fa9780a59be3e44f8653f0a66e49dc/raw/1b1c9b3407a46b492ecc1986905cc43562c0ad66/cd2025_student.py"
cd2025students = button2(cd2025students_url)
doc["cd2025students"].bind("click", cd2025students.do)
################################## cd2025students end
################################## cd2025sap start
cd2025sap_url = "https://gist.githubusercontent.com/snowfall-killer/012463ee43f80a2cf4aeaeb1116e6c6f/raw/0ce0658b5a62cce7ea44c14fdb83a75cf1ce9546/cd2025_students_account_pages.py"
cd2025sap = button2(cd2025sap_url)
doc["cd2025sap"].bind("click", cd2025sap.do)
################################## cd2025sap end
</script>
</p>
<p><!-- cd2025students 結束--></p>
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor2" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename2" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src2', 'kw_filename2');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run2">Run</button> <button id="kw_show_console2">Output</button> <button id="kw_clear_console2">清除輸出區</button><button id="clear_bd2">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console2"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div2"></div>
<!-- editor2 結束 --><hr/><h3>IPv6</h3>
<p>以系統管理員身分執行<br/>→create_account.bat</p>
<p>diable_IPv4.ps1需要更改的地方(第十四行)<br/>→$ipv6Address = "2001:288:6004:17:b009"</p>
<p>以系統管理員身分執行<br/>→ipv6set_up.bat</p>
<p>IPv6 位址：2001:288:6004:17:fff1:cd25:0000:b009<br/>預設閘道： 2001:288:6004:17::254<br/>DNS 伺服器位址<br/>慣用 DNS 伺服器：2001:288:6004:17::3<br/>其他 DNS 伺服器：2001:b000:168::1</p><h2>Task2</h2>
<h4>使用 SSH 協定執行作業倉儲的推送</h4>
<p><a href="https://zh.wikipedia.org/zh-tw/Secure_Shell">SSH</a><span> </span>是一種加密的網路傳輸協定, PuTTY 則是可用於 Windows 環境的 SSH 協定工具, 其中支援遠端登入 (putty.exe) 與檔案傳輸工具 (psftp.exe).</p>
<p>使用 PuTTY 所建立的公私鑰進行 Github push 認證的步驟:</p>
<p>第一步:</p>
<p>若希望在 Windows 環境透過 git 指令, 使用 PuTTY 設定的 session (一個代表連線伺服器主機、私鑰位置與是否使用代理主機等資訊的字串), 執行 push, 必須要在啟動可攜環境時, 設定 GIT_SSH 環境變數, 將此變數指向 PuTTY 套件中的 plink.exe 位置 (也就是 set GIT_SSH=%Disk%:\putty\plink.exe).</p>
<p>第二步:</p>
<p>指定利用 PuTTY 的 SSH session 執行 git push 後, 必須在 Windows 操作系統中選擇一個字串, 作為 SSH 連線 session 名稱, 由於此設定必須指向 SSH 協定加密用的私鑰所在目錄位置, 因此設定 session 之前, 必須利用 puttygen.txt 建立一對公私鑰, 其中的公鑰為 OpenSSH 格式, 必須送到使用者 Github 帳號設定區 (Settings) 的 SSH and GPG keys 中.</p>
<p>第三步:</p>
<p>利用 puttygen.exe 建立公私鑰的方法, 是在執行 puttygen.exe 之後, 以滑鼠按下 Generate 之後, 讓滑鼠在 puttgen.exe 視窗中 key 下方的空白區域隨意移動, puttygen.exe 會根據滑鼠移動的位置隨機建立 OpenSSH 格式的公鑰, 以及配對的 PuTTY 格式的 Private Key (副檔名為 .ppk)</p>
<p>第四步:</p>
<p>接下來, 將 OpenSSH 格式的 Public Key 內容複製到個人 Github 帳號設定區的 SSH and GPG keys 中, 並以 puttygen.exe 執行視窗右下方的 Save private key 按鈕, 將私鑰 (假設為 myprivatekey.ppk) 存至 Y:\.</p>
<p>第五步:</p>
<p>接著啟動 PuTTY 中的 putty.exe, 在 Host Name (or IP Address) 欄位填入 github.com, 並確認 Connection Type 選用 SSH, 表示要透過 SSH 加密協定連線到 github.com.</p>
<p>第六步:</p>
<p>接著在 putty.exe 視窗下方的 Saved Sessions 填入一組字串, 此字串就是之後要遠端登入 github.com 設定 push 連線 URL 的 session 名稱, 在此假設選擇 "mysession" 作為 session 名稱, 使用者可以自行選擇具有代表性的字串, 例如: 學號或簡短的英文姓名縮寫.</p>
<p>第七步:</p>
<p>在 putty.exe 視窗中填入 github.com 與 "mysession" 名稱之後, 點擊 Save 之後, 此 session 設定就會被 Windows 操作系統存入該台電腦的 Registry 登錄檔案中的 HKEY_CURRENT_USER - SOFTWARE - SimonTatham 所在組態區. 此時可以在命令列中輸入 regedit 後進入登錄檔查看是否 mysession 已經存在.</p>
<p>第八步:</p>
<p>上列 "mysession" 設定完成且按下 Save 之後, 若再按下 Open, 採用 IPv4 網路連線的電腦應該已經可以透過 putty.exe 遠端連線至 github.com, 視窗中會出現 github.com 作為視窗標題, 且內容為 login as: 但一般使用者並沒有帳號可以直接透過 putty.exe 遠端登入到 github.com, 而只能在 session 設定完成後, 利用此 session 執行 git push.</p>
<p>第九步:</p>
<p>由於前面的 "mysession" 雖然已經存入 Windows 操作系統的登錄檔, 但並沒有設定 private key 的位置, 因此接下來要再開啟 putty.exe, load 進此一 session, 然後在此 session 設定左方的 Category: 下方的 Connection - SSH - Auth - Credentials 設定中的 Private key file for authentication: 區, 利用 Browse 選擇位於 Y:\ 的 myprivatekey.ppk 檔案. 選擇檔案完成後, 必須再回到 Catetory: 下方的 Session 區, 以右方的 Save 將附加私鑰位置設定的 session 存檔. 此時 Windows 登錄檔中的 "mysession" 除了代表要使用 SSH 連線到 github.com 之外, 還附帶指定了 myprivatekey.ppk 在 Y:\ 的位置.</p>
<p>第十步:</p>
<p>若上述設定是在電腦輔助設計室中的電腦進行, 必須利用命令列 regedit 指令, 進入 HKEY_CURRENT_USER - SOFTWARE - SimonTatham 位置, 利用滑鼠右鍵將此登錄設定檔案"匯出" 存入可攜程式 start_ipv6.bat 所在目錄, 此處假設命名為 mysession.reg, 使用者可以自行對 .reg 命名.</p>
<p>第十一步:</p>
<p>由於上列的 myprivatekey.ppk 存於可攜程式中的 Y:\, 因此當使用者利用 start_ipv6.bat 啟動可攜程式後, 就可以利用滑鼠雙點擊位於同目錄的 mysession.reg, 上述的 "mysession" 設定就會存入 Windows 操作系統的登錄檔中.</p>
<p>使用 PuTTY session 設定倉儲 .git/config 中的 URL</p>
<p>假設上列 "mysession" 對應中的 OpenSSH 格式公鑰是送到 Github 帳號為 scrum-1 學員的 SSH and GPG key 區域, 則 scrum-1 學員在啟動可攜系統後, 已經雙點擊 mysession.reg, 將前述 putty.exe 設定的 session 組態登錄設定回存至 Windows 操作系統中, 則 scrum-1 學員就可以將其近端作業倉儲中的 mysession 用於倉儲 .git/config 檔案的下方設定:</p>
<div>
<div class="syntaxhighlighter js" id="highlighter_649264">
<table border="0" cellpadding="0" cellspacing="0">
<tbody>
<tr>
<td class="gutter">
<div class="line number1 index0 alt2">1</div>
<div class="line number2 index1 alt1">2</div>
<div class="line number3 index2 alt2">3</div>
</td>
<td class="code">
<div class="container">
<div class="line number1 index0 alt2"><code class="js plain">[remote </code><code class="js string">"origin"</code><code class="js plain">]</code></div>
<div class="line number2 index1 alt1"><code class="js spaces">    </code><code class="js plain">url = git@mysession:mdecd2025/hw-scrum-1.git</code></div>
<div class="line number3 index2 alt2"><code class="js spaces">    </code><code class="js plain">fetch = +refs/heads/:refs/remotes/origin/</code></div>
</div>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<p>其中的 [remote "origin"] 表示當使用 git 指令中針對此倉儲 "origin" 是一個與遠端倉儲對應的字串代號, 代表其下兩項設定. url 代表此 "origin" 的倉儲連線網址, 而連線至此倉儲的協定是採遠端登入 (使用 Github 支援的 SSH 遠端登入協定), 且此遠端登入的帳號為 "git", 這是所有要使用 SSH 執行 git push 的用戶共同使用的登入帳號.</p>
<p>url 設定中 "@" 之後的 "mysession" 就是宣告要使用此電腦登錄檔中所設定的 session 名稱 (代表要連線到 github.com, 且帶的 myprivatekey.ppk, 準備在登入流程中與 github.com 中 mdewcm2025 帳號下的 hw-scrum-1 倉儲擁有者 (或帶有 repo 管理權限的帳號) 所登錄的 public keys 進行認證比對, 一旦通過認證, git push 指令就可以成功將改版資料推送到指定的倉儲區域.</p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/B67IFVE-4ZQ?si=Yk2Hhk0yiDM7OU_C" title="YouTube video player" width="560"></iframe></p><h3>w3</h3>
<p><button id="ungroupedmember">Ungrouped_member</button></p>
<!-- 導入 brython 程式庫 -->
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫 -->
<script src="/static/Cango-24v03-min.js"></script>
<script src="/static/gearUtils-09.js"></script>
<script src="/static/SVGpathUtils-6v03-min.js"></script>
<script src="/static/sylvester.js"></script>
<script src="/static/PrairieDraw.js"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()
Ace1 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run1():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/snowfall-killer/04db27631cfb553a0e6f7dd2fc5aa797/raw/9cf2e22d729d617bca48ecaf7ce7a87b35a1cced/cd2025_Ungrouped_member.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace1.editor.setValue(prog)
    Ace1.editor.scrollToRow(0)
    Ace1.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace1.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run1'].bind('click', Ace1.run)
doc['kw_show_console1'].bind('click', Ace1.show_console)
doc['kw_clear_console1'].bind('click', Ace1.clear_console)
doc['clear_bd1'].bind('click', clear_bd1)
# 呼叫函式執行
run1()
</script>
</p>
<p><!-- Ungrouped_member 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

ungroupedmember_url = "https://gist.githubusercontent.com/snowfall-killer/04db27631cfb553a0e6f7dd2fc5aa797/raw/9cf2e22d729d617bca48ecaf7ce7a87b35a1cced/cd2025_Ungrouped_member.py"

# 從 gist 取得程式碼
add_src = open(ungroupedmember_url).read()
def add(ev):
    Ace2.editor.setValue(add_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "ungroupedmember" 的按鈕點按時, 執行 add 方法
doc["ungroupedmember"].bind('click', add)
</script>
</p>
<p><!-- Ungrouped_member --></p>
<!-- editor1 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor1" style="width: 900px; height: 600px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src1', 'kw_filename1');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run1">Run</button> <button id="kw_show_console1">Output</button> <button id="kw_clear_console1">清除輸出區</button><button id="clear_bd1">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console1"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div1"></div>
<!-- editor1 結束 --><hr/><!-- ########################################## -->
<p>
<script src="https://unpkg.com/three@0.144.0/build/three.js" type="text/javascript"></script>
</p>
<h2>Task3</h2>
<h4>使用 Solvespace 建立平面四連桿系統零組件 (HW2)</h4>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/5T9aehWOFcg?si=lwTzp6IGr7HgYLXv" title="YouTube video player" width="560"></iframe></p>
<p>Geogebra紅點移動軌跡：</p>
<p><img alt="" height="315" src="/images/four_linkage_geogebra.gif" width="560"/></p>
<h2>Task4</h2>
<p>原先想法:</p>
<p>因為隨後可以透過比對取得尚未納組的學員 Github 帳號, 且必須設法從其 Github 帳號, 取得其對應學號, 因此若能從上列程式設法建立一個 Dict, 支援輸入 Github  帳號可以回覆其對應學號, 就可以順利找出目前尚未納組的學員學號. 另外是否也必須查驗是否有學員加入錯誤的班級組別?</p>
<p>實際解法:</p>
<p>因為上列程式已經給出兩班當時已經參與分組的學員 Github 帳號, 因此只需要從<span> </span><a href="https://mde.tw/list/2b.txt">https://mde.tw/list/2b.txt</a> 讀取學員的學號與 Github 帳號, 並且在 for 迴圈中, 逐一用學員的 Github 帳號相對於各班已經參與分組的學員 Github 帳號, 並且列出特定學員的 Github 帳號不在前述已經參與分組的學員帳號數列中, 即可列出截至當時尚未那組的學員學號.</p>
<h3>w4</h3>
<p>已知目前的學員作業倉儲無法在 IPv6 位址設定時正確運作, 各學員必須下載<span> </span><a href="http://229.cycu.org/cmsimde_w4.7z">cmsimde_w4.7z</a>, 解開壓縮檔案後, 替換倉儲中的 cmsimde 目錄.</p>
<p>開始建立 Webots 模擬場景:<span> </span><a href="https://github.com/mdecycu/cd2025/discussions/2">w4 開始的練習</a></p>
<p><span>為什麼建立 Webots 場景需要先建立 Robot 物件?</span></p>
<p>在 Webots 中，建立場景時需要先建立一個 Robot 物件的原因，與 Webots 的模擬架構和工作原理密切相關。以下是詳細解釋：</p>
<p><br/>1. Webots 的核心設計理念<br/><br/>Webots 是一個用於模擬機器人行為的平台，它的場景（world）是由多個物件（nodes）組成的樹狀結構。而 Robot 物件是一個特殊的節點（node），它不僅代表一個實體機器人，還承載了與模擬環境交互的核心功能，例如感測器、執行器和控制器。沒有 Robot 物件，場景就缺少一個主體來執行具體的任務或行為，模擬也就失去了意義。</p>
<p>2. Robot 物件的功能<br/><br/>    控制器綁定：每個 Robot 物件都需要指定一個控制器（controller），這是用來定義機器人行為的程式（可以用 C、C++、Python 等語言編寫）。沒有 Robot，就無法運行控制器，也無法模擬機器人的動作或決策。<br/>    感測器與執行器：Robot 物件是感測器（例如攝影機、距離感測器）和執行器（例如馬達、輪子）的容器。這些設備必須依附於一個 Robot 節點才能運作。<br/>    物理屬性：Robot 物件定義了機器人在模擬環境中的物理存在，例如位置、質量和形狀。如果沒有這個物件，場景中就沒有可以與物理引擎交互的實體。<br/><br/>3. 場景的結構要求<br/><br/>在 Webots 中，場景檔案（.wbt 檔案）是一個層次化的描述，所有的節點都必須遵循一定的語法規則。Robot 節點通常作為場景中的頂層節點之一，直接或間接連接到根節點（World）。如果沒有 Robot，場景可能只包含靜態物件（例如牆壁或地板），但無法進行動態模擬，因為缺少能夠主動參與模擬的實體。</p>
<p>4. 實際操作中的必要性<br/><br/>當你建立一個 Webots 場景時，通常的目的是模擬某個機器人的行為（例如移動、避障、抓取物品等）。因此，第一步通常是定義一個 Robot 物件，然後在這個物件下添加必要的子節點（例如 DifferentialWheels、感測器等），以實現模擬目標。換句話說，Robot 是場景的起點，沒有它，後續的配置就無從談起。</p>
<p>總結<br/><br/>建立 Webots 場景需要先建立 Robot 物件，因為它是模擬的核心實體，承載了控制器、感測器、執行器和物理屬性等功能。沒有 Robot，場景就只是一個靜態的環境，無法實現動態的機器人模擬。這是 Webots 設計上的基本要求，也是模擬流程的邏輯起點。</p>
<p><span>Webots 在建立連桿機構模型時, 是否無法建立 closed chain 機構的 kinematics 模型, 只能建立 dynamic model?</span></p>
<p>在 Webots 中，建立連桿機構模型時，的確有一些限制。Webots 是一個仿真軟體，主要用於機器人和機械系統的動態仿真，並且使用的模型大多是基於動態模型（dynamic models）來進行運算和仿真。對於一個閉環機構（closed-chain mechanism），Webots 不提供直接建立其運動學（kinematics）模型的工具或算法。</p>
<p>1. 關於閉環機構的幾點說明：<br/><br/>    運動學（Kinematics）是描述機構運動的幾何學模型，通常關注的是位置、速度和加速度等。<br/>    動力學（Dynamics）則是考慮外力、慣性、摩擦等物理因素，描述機構在運動過程中的力學行為。<br/><br/>2. Webots 中的模型類型：<br/><br/>    Webots 主要依賴動力學模型來處理仿真，這些模型包括力學運算、質量、慣性矩等。在處理一個閉環機構（例如機械手臂中帶有閉環結構的部分）時，Webots 更加強調的是系統的運動學和動力學的結合，並通過數值積分來解決動態方程，而不是像一些其他專門的運動學求解軟體（如 MATLAB、Adams 等）一樣單獨進行運動學建模。<br/><br/>3. 關於閉環機構的仿真：<br/><br/>    當建立閉環機構模型時，Webots 並不直接提供基於閉環運動學的求解器。相反，Webots 會通過動態模型，並將閉環運動的約束作為力學條件來進行處理。因此，它會基於質量、力和慣性等動態特徵來解算運動。<br/>    若需要精確的運動學建模，可以考慮在外部工具中（如 MATLAB、Simulink 或 ROS）進行運動學建模，再將結果導入到 Webots 進行動態仿真。<br/><br/>總結：<br/><br/>Webots 在處理閉環機構時，主要側重於動力學模型的建立，而不是運動學模型。它能夠處理閉環結構的動態行為，但不直接提供基於運動學的閉環求解。對於複雜的運動學分析，可能需要借助其他專業工具來處理，然後將結果匯入 Webots 進行仿真。</p>
<p data-pm-slice="1 1 []"><span>請就此點與 CoppeliaSim 建模進行比較</span></p>
<p>在建模閉環機構（closed-chain mechanism）時，<strong>CoppeliaSim</strong>（原名 V-REP）和<span> </span><strong>Webots</strong><span> </span>之間的區別主要體現在它們對運動學（kinematics）和動力學（dynamics）的處理方式上。</p>
<h4><strong>Webots 的建模特點：</strong></h4>
<ol>
<li>
<p><strong>動力學為主</strong>：</p>
<ul>
<li>Webots 強調的是機構的動力學模型，通過質量、慣性矩、力學約束等來描述機構的運動。當處理閉環機構時，Webots 並不直接提供運動學的求解過程，而是依賴動力學來解決運動方程。</li>
<li>它的仿真是基於數值積分的動態仿真，並且處理的是物理層面上的相互作用，這意味著它更多地側重於如何模擬機構的動力學行為（如速度、加速度、力等）而非僅僅描述機構的幾何運動。</li>
<li>在設計複雜的閉環機構時，通常需要考慮機構的運動限制，這些限制會作為力學約束條件（例如接觸力、摩擦力、鉸鏈等）納入動力學模型中來進行仿真。</li>
</ul>
</li>
<li>
<p><strong>閉環機構的動態仿真</strong>：</p>
<ul>
<li>Webots 不能直接生成閉環機構的運動學模型（例如雅可比矩陣、運動方程），但它可以處理這些機構的動力學模型並通過數值方法解算運動。閉環機構的運動限制通常會通過編程或物理約束來處理。</li>
</ul>
</li>
</ol>
<h4><strong>CoppeliaSim 的建模特點：</strong></h4>
<ol>
<li>
<p><strong>強調運動學與動力學結合</strong>：</p>
<ul>
<li>CoppeliaSim 在處理閉環機構時，與 Webots 類似，主要處理的是機構的<strong>動力學仿真</strong>，但它同時也具備更強大的<strong>運動學分析功能</strong>。它支持基於機構運動學的建模，並且能夠生成雅可比矩陣、運動學方程等。</li>
<li>在 CoppeliaSim 中，可以直接利用其內建的運動學求解器來處理複雜的運動學問題（例如多自由度機械手臂、閉環機構等），這使得它能夠提供精確的運動學分析，並且可以基於這些分析結果進行動態仿真。</li>
</ul>
</li>
<li>
<p><strong>運動學建模和約束處理</strong>：</p>
<ul>
<li>CoppeliaSim 允許在機構建模過程中使用<strong>運動學約束</strong>來定義閉環結構。這意味著，使用者可以明確地定義機構的各個部件如何運動、約束其位置、速度等，甚至可以設置關節限制、碰撞檢測等。這些運動學約束和幾何關係被用來確保機構在仿真過程中遵循合理的運動軌跡。</li>
<li>CoppeliaSim 提供了許多現成的機構建模元件，如彈簧、齒輪、連桿等，並支持用戶自定義機構和關節的運動學約束。</li>
</ul>
</li>
<li>
<p><strong>更多的控制和交互性</strong>：</p>
<ul>
<li>CoppeliaSim 提供了豐富的控制接口，並支持與外部系統進行聯動（如 ROS、Python 等）。這使得用戶可以實現對閉環機構的控制，並將控制策略與運動學和動力學仿真結合起來。</li>
<li>它也提供了反向運動學（Inverse Kinematics, IK）解算器，對於機械手臂等應用，能夠簡化運動學的建模過程。</li>
</ul>
</li>
</ol>
<h4><strong>總結比較：</strong></h4>
<table>
<thead>
<tr>
<th>特性</th>
<th><strong>Webots</strong></th>
<th><strong>CoppeliaSim</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>建模重點</strong></td>
<td>動力學仿真為主，基於物理規則計算運動</td>
<td>結合運動學與動力學，提供更高層次的建模功能</td>
</tr>
<tr>
<td><strong>運動學分析</strong></td>
<td>不直接處理運動學，基於動力學解算運動</td>
<td>提供運動學求解器，支持雅可比矩陣和運動方程</td>
</tr>
<tr>
<td><strong>閉環機構處理</strong></td>
<td>需要通過物理約束來實現</td>
<td>可通過運動學約束和動力學約束建模閉環機構</td>
</tr>
<tr>
<td><strong>運動學求解器</strong></td>
<td>不提供運動學求解器</td>
<td>提供運動學求解器，支持反向運動學解算</td>
</tr>
<tr>
<td><strong>開發與控制接口</strong></td>
<td>支持與外部控制系統連接（如 ROS）</td>
<td>支持多種控制接口，易於與外部系統集成</td>
</tr>
<tr>
<td><strong>易用性與功能豐富度</strong></td>
<td>偏向於動力學仿真，適合模擬機器人運動</td>
<td>提供完整的運動學和動力學建模，適合精細建模</td>
</tr>
</tbody>
</table>
<h4>結論：</h4>
<ul>
<li>如果你專注於<strong>動態仿真</strong>，並且希望更強調機構的物理交互，<strong>Webots</strong><span> </span>是一個很好的選擇。</li>
<li>如果你需要一個結合<strong>運動學與動力學</strong>的工具，並且希望進行更精細的機構建模，<strong>CoppeliaSim</strong><span> </span>提供了更多的功能來處理閉環機構的運動學約束和動力學行為。它對於處理複雜的運動學問題（例如逆運動學）以及閉環機構的建模可能更加靈活。</li>
</ul>
<p>因此，選擇哪個平台取決於你的具體需求，如果你需要較高層次的運動學建模，CoppeliaSim 可能更適合；如果重點在於機構的動態仿真和控制，Webots 可能是更好的選擇。</p>
<p></p>
<h4>使用 Onshape 建立平面四連桿系統零組件 (HW2)</h4>
<p>連桿尺寸依據:<span> </span><a href="https://mdecd2025.github.io/hw-scrum-1/downloads/fourbar_slvs.7z">fourbar_slvs.7z</a></p><h3>w5</h3>
<p>內容一：</p>
<p>內容二：</p>
<p dir="auto">接下來, 我們將說明如何在 Webots 中利用簡單的 box 物件建立 link, 利用 HingeJoint 建立 旋轉軸, 並且利用 Python controller 程式控制 link 的旋轉, 以下的模擬場景為可分別針對 link1, link2, link3 控制旋轉的 Open chain 運動模型, 請各組接續完成 Closed chain 的 box 四連桿運動場景. 完成後請詳細說明各連接桿與連接軸的設定步驟, 將說明以及操作影片分別放入個人與分組的倉儲及網頁中.</p>
<p dir="auto"><a href="https://mdecd2025.github.io/hw-scrum-1/downloads/cd2025_box_fourbar.zip">cd2025_box_fourbar.zip</a></p>
<p dir="auto">平面四連桿的尺寸設計：<br/>固定桿長度為 1m<br/>主動旋轉桿長度為 0.4m<br/>第二旋轉桿長度為 0.6m<br/>第三旋轉桿長度為 0.9m</p>
<p dir="auto">工具: Webots R2025a, Solvespace 3.1, Python 3.13.2, 可攜程式環境 wcm2025</p>
<p dir="auto">希望完成的模擬結果如下：</p>
<p dir="auto"><img alt="" height="270" src="/images/four_linkage_box.gif" width="480"/></p>
<p dir="auto"></p><h3>w6</h3>
<h2>Task5</h2>
<h4>Webots Tutorial 1 ~3 (HW3)</h4>
<p><a href="https://cyberbotics.com/doc/guide/introduction-to-webots" target="_blank">https://cyberbotics.com/doc/guide/introduction-to-webots</a></p>
<ol>
<li>請用繁體中文詳細說明下列資料:<span> </span><a href="https://cyberbotics.com/doc/guide/introduction-to-webots" target="_blank">https://cyberbotics.com/doc/guide/introduction-to-webots </a>
<p><strong>什麼是 Webots？</strong><br/>Webots 是一套專業的移動機器人模擬軟體。它提供一個快速原型設計的環境，允許使用者建立具備物理屬性的 3D 虛擬世界，例如質量、關節、摩擦係數等。 使用者可以加入被動物件（如障礙物）或主動物件（稱為移動機器人）。這些機器人可以採用不同的移動方式（如輪式、步行式或飛行型）。此外，它們可以配備多種感測器與致動器裝置，例如：距離感測器、驅動輪、攝影機、馬達、觸碰感測器、訊號發射器與接收器等。 最終，使用者可以為每個機器人撰寫個別的控制程式，實現預期的行為。Webots 內建大量的機器人模型與控制器程式範例，可協助使用者快速上手。 Webots 也提供與真實移動機器人的接口，因此當模擬中的機器人表現如預期時，可以將其控制程式轉移至實體機器人，如 e-puck、DARwIn-OP、Nao 等。若有需要，也可自行開發與新增新的機器人接口。</p>
<p><strong>我可以用 Webots 做什麼？</strong><br/>Webots 特別適合用於與移動機器人相關的<strong>研究與教育專案</strong>。多年來，許多研究與應用都依賴 Webots，範圍包括： - 移動機器人原型設計（學術研究、汽車產業、航空產業、吸塵器產業、玩具產業、業餘愛好者等） - 機器人移動研究（如步行、仿人、四足機器人等） - 多代理系統研究（群體智慧、協作型移動機器人等） - 適應性行為研究（遺傳演算法、神經網路、人工智慧等） - 教學用途（機器人學課程、C/C++/Java/Python 課程等） - 機器人競賽（如 Robotstadium、Rat’s Life 等）</p>
<p><strong>使用 Webots 需要具備哪些知識？</strong><br/>若要開發自己的模擬專案，您需要具備以下基本技術知識： -<strong>程式語言基礎</strong>：您需要具備 C、C++、Java、Python 或 MATLAB 的基本程式設計知識，以撰寫機器人的控制程式。不過，即使您不熟悉這些語言，也可以使用名為<strong>BotStudio</strong>的圖形化編程工具，來編程 e-puck 或 Hemisson 機器人。 -<strong>3D 建模基礎（選擇性）</strong>：若您想自訂機器人模型或在模擬環境中新增特殊物件，您需瞭解基本的 3D 圖形與 VRML97 描述語言。這將協助您自行建立 3D 模型，或從其他建模軟體匯入模型。</p>
<p><strong>如何獲得使用者支援？</strong><br/>Cyberbotics 提供付費的<strong>Premier Service 計畫</strong>與<strong>客製化開發服務</strong>。 此外，也有以下社群支援資源（但無保證一定會得到回覆）： - [Robotics StackExchange](<a href="https://robotics.stackexchange.com/questions/tagged/webots">https://robotics.stackexchange.com/questions/tagged/webots</a>)：最佳的技術問題發問平台。 - [GitHub Discussions](<a href="https://github.com/cyberbotics/webots/discussions">https://github.com/cyberbotics/webots/discussions</a>)：可用於關於 Webots 開發與文件的討論。 - [GitHub Issues](<a href="https://github.com/cyberbotics/webots/issues">https://github.com/cyberbotics/webots/issues</a>)：僅用來回報 Webots 的錯誤。 - [Webots Discord](<a href="https://discord.com/invite/nxweYMW">https://discord.com/invite/nxweYMW</a>)：用於快速問答與即時討論</p>
<p><strong>什麼是 Webots 模擬？</strong><br/>Webots 的模擬包含以下要素： -<strong>世界檔 (.wbt)</strong>：定義一個或多個機器人及其環境。此檔案可能依賴外部的<strong>PROTO 檔案 (.proto)</strong>和<strong>貼圖素材</strong>。 -<strong>控制器程式</strong>：針對上述機器人撰寫的程式（可使用 C/C++/Java/Python/MATLAB）。 -<strong>物理外掛（選用）</strong>：可用 C/C++ 編寫，以修改 Webots 的預設物理行為。</p>
<p><strong>什麼是「世界」（World）？</strong><br/>在 Webots 中，「世界」是對機器人與環境屬性的 3D 描述。它包含每個物件的： - 位置與方向 - 幾何形狀與外觀（如顏色、亮度） - 物理屬性 - 物件類型（如機器人、障礙物） 世界是階層式結構（類似 VRML97），例如：一個機器人可包含兩個輪子、一個距離感測器與一個含攝影機的關節。<strong>世界檔</strong>不包含控制器程式碼，它只指定每個機器人所需對應的控制器名稱。這些檔案儲存為「.wbt」格式，並放在每個 Webots 專案的 `worlds` 子資料夾中。</p>
<p><strong>什麼是控制器（Controller）？</strong><br/>控制器是一段控制模擬中機器人的程式碼，可使用 Webots 支援的任一語言編寫（C、C++、Java、Python、MATLAB）。 當模擬啟動時，Webots 為每個指定的控制器啟動一個獨立程序，並將其與對應的機器人關聯。多個機器人可以共用同一段控制程式，但每台機器人仍會啟動自己的執行程序。 程式語言的處理方式如下： - C 與 C++：<strong>需編譯</strong>為平台依賴的可執行檔（如 Windows 的 `.exe`） - Python 與 MATLAB：<strong>需直譯</strong>執行（需安裝相應的執行環境） - Java：需先編譯為位元碼（如 `.class` 或 `.jar`），再由 Java 虛擬機（JVM）執行 控制器的原始碼與編譯檔案會被儲存在「controllers」子資料夾內的控制器目錄中。</p>
<p><strong>什麼是 Supervisor Controller（監督控制器）？</strong><br/>Supervisor Controller 是設定為具有「supervisor = TRUE」屬性的機器人的控制程式。它可執行一般機器人無法執行的「特權操作」，如： - 控制整個模擬的狀態 - 移動機器人到隨機位置 - 錄製模擬影像 它可以使用與一般控制器相同的語言撰寫，但具備額外權限，適用於進階模擬控制與管理用途。</p>
</li>
<li>請整理<span> </span><a href="https://cyberbotics.com/doc/guide/introduction-to-webots" target="_blank">https://cyberbotics.com/doc/guide/introduction-to-webots</a><span> </span>中重要的英文單字與用法, 並且針對其中所使用的英文文法逐句說明.</li>
<li>請摘要出下列內容: (放入英文文章內容)
<p><strong>What is Webots?</strong><br/> Webots is a <strong>professional robot simulation software</strong> for creating 3D virtual environments with physics. You can simulate robots (wheeled, legged, flying) with sensors and actuators like cameras, motors, and distance sensors. It supports programming each robot's behavior individually.</p>
<p><strong>Main Features:</strong></p>
<ul style="list-style-type: square;">
<li>Rapid prototyping with physics-based simulation.</li>
<li>Multiple robot types and movement systems.</li>
<li>Programmable in C, C++, Java, Python, MATLAB.</li>
<li>Includes many robot models and controller examples.</li>
</ul>
<p><strong>Applications:</strong></p>
<ul style="list-style-type: square;">
<li>Academic and industrial robot prototyping</li>
<li>Locomotion and multi-agent system research</li>
<li>Adaptive behavior using AI methods</li>
<li>Teaching robotics and programming</li>
<li>Robot competitions</li>
</ul>
<p><strong>What You Need to Know:</strong></p>
<ul style="list-style-type: square;">
<li>Basic coding skills in supported languages</li>
<li>Optional 3D modeling knowledge (VRML97) for custom robots or objects</li>
</ul>
<p><strong>Support:</strong></p>
<ul style="list-style-type: square;">
<li>Paid support from Cyberbotics</li>
<li>Community support via StackExchange, GitHub, Discord</li>
</ul>
<p><strong>Simulation Components:</strong></p>
<ul style="list-style-type: square;">
<li><strong>World file (.wbt)</strong>: Describes environment and robot structure</li>
<li><strong>Controller programs</strong>: Control robot behavior</li>
<li><strong>Physics plugin (optional)</strong>: Customize physics interactions</li>
</ul>
<p><strong>Controller Types:</strong></p>
<ul style="list-style-type: square;">
<li><strong>Regular controllers</strong>: One per robot, written in supported languages</li>
<li><strong>Supervisor controllers</strong>: Have special privileges (e.g., reposition robots, record videos)</li>
</ul>
</li>
<li>請列出上述文章中的重要的英文單字與解釋, 以及出現在文句中的用法:</li>
<li>請詳細說明如何採手動方式在 Webots 建立下列場景:</li>
</ol>
<p><strong>Webots 手動建立模擬場景教學</strong></p>
<p><strong>目標場景結構：</strong></p>
<ol>
<ol>
<li>一個地板（地面）</li>
<li>四面牆形成一個封閉空間</li>
<li>一個輪型機器人（如 e-puck）</li>
<li>機器人裝有一個距離感測器</li>
<li>使用 Webots 的 GUI 介面（非程式碼）手動建立</li>
</ol>
</ol>
<p><strong>建立步驟：</strong></p>
<p><strong>1. 建立新專案</strong></p>
<ol>
<ol>
<li>開啟 Webots。</li>
<li>選擇「<strong>File &gt; New Project Directory</strong>」。</li>
<li>命名後點選「Create」。Webots 會自動建立以下資料夾：
<ul>
<li><code>worlds/</code></li>
<li><code>controllers/</code></li>
<li><code>protos/</code></li>
</ul>
</li>
</ol>
</ol>
<p><strong>2. 建立新世界 (World)</strong></p>
<ol>
<ol>
<li>點選「<strong>File &gt; New World</strong>」。</li>
<li>存檔為 <code>my_world.wbt</code> 到 <code>worlds/</code> 資料夾。</li>
<li>畫面上會有預設的 <code>RectangleArena</code>，你可以刪掉或保留。</li>
</ol>
</ol>
<p><strong>3. 加入地面 (Floor)</strong></p>
<ol>
<ol>
<li>在左側 <strong>Scene Tree</strong>，右鍵 <code>root</code> → <code>Add &gt; Solid &gt; Floor</code>。</li>
<li>在右側 <strong>Field Editor</strong> 調整大小與材質。</li>
</ol>
</ol>
<p><strong>4. 加入牆壁 (Wall)</strong></p>
<p>重複以下步驟四次來建構四面牆：</p>
<ol>
<ol>
<li>右鍵 <code>root</code> → <code>Add &gt; Solid &gt; Box</code>。</li>
<li>設定 <code>size = [0.1, 2, 1]</code>（厚度 x 長度 x 高度）。</li>
<li>調整 <code>translation</code> 移到場景邊界，例如：<code>[-1, 0, 0.5]</code>。</li>
</ol>
</ol>
<p><strong>5. 加入輪型機器人 (e-puck)</strong></p>
<ol>
<ol>
<li>右鍵 <code>root</code> → <code>Add &gt; Robot &gt; e-puck</code>。</li>
<li>設定 <strong>controller</strong> 欄位為 <code>epuck_controller</code>。</li>
</ol>
</ol>
<p><strong>6. 加入距離感測器 (Distance Sensor)</strong></p>
<ol>
<ol>
<li>展開 e-puck 階層。</li>
<li>右鍵子元件 → <code>Add &gt; Device &gt; DistanceSensor</code>。</li>
<li>命名為 <code>ds_front</code>，啟用 <code>slot</code> 與 <code>name</code>。</li>
</ol>
</ol>
<p><strong>7. 儲存世界</strong></p>
<ul>
<ol>
<li>選擇「<strong>File &gt; Save World</strong>」，儲存為 <code>.wbt</code> 世界檔。</li>
</ol>
</ul>
<p><strong>建立控制器程式（Python 範例）</strong></p>
<ul>
<ol>
<li>在 <code>controllers/</code> 建立 <code>epuck_controller/</code> 資料夾。</li>
<li>新增 <code>epuck_controller.py</code>，內容如下：</li>
</ol>
</ul>
<pre class="brush:py;auto-links:false;toolbar:false" contenteditable="false">from controller import Robot

robot = Robot()
timestep = int(robot.getBasicTimeStep())

# 初始化距離感測器
ds = robot.getDevice('ds_front')
ds.enable(timestep)

while robot.step(timestep) != -1:
    val = ds.getValue()
    print("Distance:", val)</pre>
<p>回到 Webots，確認 e-puck 的 controller 欄位為 <code>epuck_controller</code>。</p>
<p><strong>開始模擬</strong></p>
<ol>
<ol>
<li>點選「<strong>Simulation &gt; Run</strong>」或按 Ctrl+R。</li>
<li>你會在 Console 中看到距離數值不斷被列印出來。</li>
</ol>
</ol>
<p><strong>延伸建議</strong></p>
<ol>
<ol>
<li>使用 Supervisor 控制場景動態</li>
<li>加入攝影機、觸碰感測器等設備</li>
<li>建立自訂的 <code>.proto</code> 模型</li>
</ol>
</ol>
<p>希望可以手把手一步步說明該如何利用圖形介面 menu 建立這個場景, 過程中有那些要點必須特別注意?</p><h2>Task6</h2>
<h4>Webots Tutorial 4 ~6 (HW3)</h4>
<p>Webots 啟動時，同時啟動串流伺服器指令: webotsw --stream</p>
<p>內建埠號為 1234，由於採用 WebGL2 進行網頁著色，因此在 Windows 環境中使用 Edge 連線至<span> </span><a href="http://localhost:1234/">http://localhost:1234</a> 或<span> </span><a href="http://stream_server_ip:1234/">http://stream_server_ip:1234</a><span> </span>將會較為順暢.</p>
<p>至於希望利用 display 展示投籃成績的方法，僅能在近端 Webots 套件中檢視，因此若要讓記分板或計時器能在串流瀏覽器中展示，必須採用 7 段顯示器設置，並利用 supervisor 模式進行操控.</p>
<p>利用 Solvespace 繪製的 7 段顯示器零組件檔案: <a href="https://mdecd2025.github.io/hw-scrum-1/downloads/score_counter.7z">score_counter.7z</a></p>
<p>若要在 Webots 中利用變顏色的 .obj 零件顯示數字, 可以透過 Solid - Shape - Mesh 然後將 url 指向 7 段顯示器中的 a ~ g 零件, 並且利用 controller 改變各零件的顏色.</p>
<p>利用 r, b, y, g 按鍵改變 7 段顯示器中的 f 零件示範場景: <a href="https://mdecd2025.github.io/hw-scrum-1/downloads/7_segment_display.7z">7_segment_display.7z</a>, 執行結果如下:</p>
<p><img alt="" height="328" src="https://mdecd2025.github.io/hw-scrum-1/images/solid_shape_mesh_color_changed.gif" width="400"/></p>
<p><a href="https://mdecd2025.github.io/hw-scrum-1/downloads/three_digit_counter.7z">three_digit_counter.7z</a></p>
<h1>Homework</h1>
<p>作業 (30%)</p>
<p>HW1 (5%): <span style="background-color: #ffff00;">建立由 Box 組成的平面四連桿機構 Webots 模擬場景</span></p>
<p style="padding-left: 30px;">part1:</p>
<p style="padding-left: 60px;">請各學員在 USB 隨身碟或個人電腦上完成 cd2025 課程所需的可攜系統配置:</p>
<p style="padding-left: 90px;">下載 <a href="http://229.cycu.org/portable_wcm2025.7z">portable_wcm2025.7z</a> (330MB, 解開壓縮後 1.4GB)</p>
<p style="padding-left: 90px;"><a href="http://229.cycu.org/Webots_2025a.7z">Webots_2025a.7z</a> (1.5 GB, 解開後約為 2.9GB, 可單獨運作)</p>
<p style="padding-left: 90px;"><a href="http://229.cycu.org/Webots_2025a_web.7z">Webots_2025a_web.7z</a> (171 MB, 解開壓縮後約為 1GB, 必須連網運作)</p>
<p style="padding-left: 90px;"><a href="http://229.cycu.org/Blender4.2.7z">Blender4.2.7z</a></p>
<p style="padding-left: 30px;">part2:</p>
<p style="padding-left: 60px;">請各學員完成可攜程式系統配置後, 利用 Webots R2025a 中寬度與高度都為 0.1m 的 box 物件建立一個簡單的平面四連桿機構模擬場景.</p>
<p style="padding-left: 60px;">base (基座) 長度 1m, link1 長度 0.4m, link2 長度 0.6m, link3 長度 0.9m, 各轉軸均為 HingeJoint, joint1 旋轉速度設定為 1radian/sec.</p>
<p style="padding-left: 30px;">part3:</p>
<p style="padding-left: 60px;">模擬場景啟動後, 按下 s 鍵機構開始作動, 按下 p 鍵後機構暫停.</p>
<p style="padding-left: 30px;">參考資料:</p>
<p style="padding-left: 60px;"><a href="/downloads/cd2025_hw1_demo.7z">cd2025_hw1_demo.7z</a></p>
<p>HW2 (5%): <span style="background-color: #ffff00;">建立由 CAD 繪製零件組成的平面四連桿機構 Webots 模擬場景</span></p>
<p style="padding-left: 30px;">各學員請利用 CAD 系統依據 HW1 的連桿尺寸與運動方式, 配置適當大小的旋轉軸以及基座後, 利用 Webots R2025a 完成一個簡單的平面四連桿機構模擬場景.</p>
<p style="padding-left: 30px;">參考資料:</p>
<p style="padding-left: 60px;"><a href="/downloads/fourbar_slvs.7z">fourbar_slvs.7z</a></p>
<p>HW3 (20%):<span style="background-color: #ffff00;">建立 Webots 桌上籃球遊戲機模擬系統</span></p>
<p style="padding-left: 30px;">請各分組利用CAD 系統建立一個能在電腦桌 (1600W X 700D X 740H mm) 上運作的投籃機構 (<a href="https://www.youtube.com/watch?v=LloG_Jn_TI0&amp;t=51s">參考影片</a>)後, 導入 Webots R2025a 套件, 建立一個能由使用者透過鍵盤按鍵操作, 且具備計分板的籃球遊戲機模擬系統.</p>
<p style="padding-left: 30px;">參考資料:</p>
<p>參考資料:</p>
<p style="padding-left: 30px;"><a href="/downloads/fourbar_ball_throwing_linkage.slvs">fourbar_ball_throwing_linkage.slvs</a></p>
<p style="padding-left: 30px;"><a href="/downloads/sixbar_ball_throwing_linkage.slvs">sixbar_ball_throwing_linkage.slvs</a></p>
<p style="padding-left: 30px;"><img alt="" height="264" src="/images/fourbar_ball_throwing_linkage.gif" width="400"/></p>
<h2>HW1</h2>
<p>HW1 (5%): <span style="background-color: #ffff00;">建立由 Box 組成的平面四連桿機構 Webots 模擬場景</span></p>
<p>操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW1 - 41023218</p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/CqOngn4yLbw?si=hPUPc34hCKPBeFnh" title="YouTube video player" width="560"></iframe></p><h2>HW2</h2>
<p>HW2 (5%): <span style="background-color: #ffff00;">建立由 CAD 繪製零件組成的平面四連桿機構 Webots 模擬場景</span></p>
<p>操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW2 - 學員學號</p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/kxtgQcIE2A8?si=r6frFNSNBVVoPC-x" title="YouTube video player" width="560"></iframe></p><h2>HW3</h2>
<p>HW3 (20%):<span style="background-color: #ffff00;">建立 Webots 桌上籃球遊戲機模擬系統</span></p>
<p>操作影片標題: 國立虎尾科技大學 - 機械設計工程系 - cd2025 HW3 - 學員學號</p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/fqMPgWbFGFU?si=cH6tJ-SxERLbpEfe" title="YouTube video player" width="560"></iframe></p>
<p>問題：目前投籃機可投籃，但是進球不會顯示得分。</p><h1>Midterm</h1>
<p>本課程所繳交的期中成績為學員自評之學習期望成績.</p>
<p>期中考週的自評期望成績繳交流程:</p>
<ol>
<li>整理先前所完成的各週的進度、作業網頁內容以及心得</li>
<li>拍攝期中自評影片, 上傳至 Youtube 後, 以"<span style="background-color: #ffff00;">國立虎尾科技大學 - 機械設計工程系 - cd2025 期中自評- 學員學號</span>"為影片標題後嵌入本頁面中</li>
<li>回填期中自評表單</li>
<li>上傳學員期中成績</li>
</ol>
<p>各週進度:</p>
<p>W1：個人倉儲</p>
<p>W2：加入list</p>
<p>W3：分組加入第9組</p>
<p>W4：個人倉儲改用近端SSH</p>
<p>W5：solvespace繪圖</p>
<p>W6：Onshape繪圖、Webots入門</p>
<p>W7：Webots入門</p>
<p>W8：Webots using box, Webots using mesh</p>
<p>W9：成功導入.obj檔案以及Webots動態模擬</p>
<p>各週網頁內容:</p>
<p><a href="https://mdecd2025.github.io/hw-snowfall-killer/content/Task1.html">Task</a></p>
<p>期中心得:</p>
<p>第四週想要開啟近端修改資料，結果Replit、Codespaces後續都沒辦法使用(Web cannot be exposed)，後來慢慢改用進端SSH推送資料，目前Webots 動態模擬Pose 設定還需再了解其中的原理</p>
<p>期中自評影片:</p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/3M5YSATvOno?si=SQeOevjRJ1aKPH7o" title="YouTube video player" width="560"></iframe></p>
<p style="padding-left: 30px;"></p><h1>Exam</h1>
<p>Exam1 (10%): 建立 Webots 基本物件模擬場景</p>
<p style="padding-left: 30px;">各學員利用 Webots R2025a 套件中的 Shape 物件, 隨堂建立指定的機電系統模擬場景, 並利用 Python 程式進行互動控制.</p>
<p>Exam2 (10%): 利用 CAD 零組件建立模擬場景 </p>
<p style="padding-left: 30px;">各學員利用 CAD (Solvespace 與 NX2312), 隨堂建立指定的系統模型零組件後, 導入 Webots R2025a 後, 建立機電系統模擬場景, 並利用 Python 程式進行互動控制.</p>
<p>Exam3 (20%): Webots 機電模擬場景的協同設計</p>
<p style="padding-left: 30px;">各分組利用 CAD (Solvespace 與 NX2312), 隨堂建立指定的系統模型零組件後, 導入 Webots R2025a 後, 建立機電系統模擬場景, 並利用 Python 程式進行互動控制. 過程中各學員必須採同步協同模式, 維護從 Github Classroom 取得的分組協同倉儲以及網站.</p>
<p style="padding-left: 30px;">協同分組方式:</p>
<ol>
<li>分配學員負責利用 Solvespace 建立系統零組件, 過程中必須將所建構之零組件檔案與繪圖過程影片上傳至分組網頁.</li>
<li>分配學員負責利用 NX2312 建立系統零組件, 過程中必須將所建構之零組件檔案與繪圖過程影片上傳至分組網頁.</li>
<li>分配學員負責利用 Webots 建立機電系統模擬場景, 並利用 Python 程式進行控制, 過程中必須將建構過程拍成帶有說明字幕的影片上傳至分組網頁.</li>
</ol>
<h2>Exam1</h2>
<p>Exam1 (10%)：建立 Webots 基本物件模擬場景</p>
<p>紅色連桿為主動旋轉，其旋轉速度設為1.0 rad/s，長度為0.4m。</p>
<p><span style="background-color: #00ff00;">起始角度18°</span></p>
<p>綠色基座長端為0.6m，短端長度為0.3m，基座短端位於長桿中央且與基座長桿重疊。</p>
<p>藍色連桿長度為0.9m，紅色連桿與藍色連桿距離則為1m。</p>
<ol>
<li>加入Robot</li>
<li>在Robot下加入Solid命名為base。</li>
<li>在Solid下加入第一個HingeJoint節點，命名為joint1。</li>
<li>joint1→endpoint選擇新增Solid節點，命名為link1。</li>
<li>joint1→endpoint→translation(x,y,z)設定(-0.5,0,0.1)，此為轉軸的座標。</li>
<li>joint1→endpoint→rotation(x,y,z,angle)設為(0,0,1,0.314)。<br/>角度為學號後兩碼18°轉θ = 0.314 rad。</li>
<li><span>joint1→endpoint</span><span>→children</span>新增第一個Pose命名為link1和新增第二個HingeJoint命名為joint2。</li>
<li><span>joint1→endpoint</span><span>→children→</span>第一個Pose<span>→</span>children加入Shape作為link1。</li>
<li>Shape下的geometry加入box作為link1，size為(0.4,0.1,0.1)。</li>
<li><span>joint1→endpoint</span><span>→children→</span>第一個Pose<span>→</span>translation設為link1長度的一半(0.2,0,0)。</li>
<li><span>joint1→endpoint</span><span>→children新增</span>第二個Hingejoint命名為joint2，endpoint新增Solid命名為link2。</li>
<li>joint2→endpoint→translation設(0.4,0,0.1)，此為轉軸2的座標，z軸提高0.1m以防止模型穿模。</li>
<li><span>joint2→endpoint→rotation設為(0,0,1,1.12)，</span><span>64.56°轉θ = 1.12 rad。</span></li>
<li><span>joint2→endpoint→</span>children<br/>新增<span>第三個Hingejoint命名為</span>joint3，<br/>新增第二個Pose命名為link2-1，<br/>新增第三個Pose命名為link2-2。</li>
<li><span>第二個Pose(link2-1)→children→Shape→geometry加入box作為link2-1，size為(0.6,0.1,0.1)。</span></li>
<li><span>第二個Pose(link2-1)→translation設為link2-1長度的一半(0.3,0,0)。</span></li>
<li><span>第三個Pose(link2-2)→children→Shape→geometry加入box作為link2-2，size為(0.1,0.3,0.1)。</span></li>
<li><span>第三個Pose(link2-2)→translation設為link2-2長度的一半(0.3,0.15,0)。</span><span></span></li>
<li><span>joint1</span><span>→endpoint</span><span>→children→</span><span>joint2→endpoint→</span><span>children→</span>joint3<span>新增Solid命名為link3。</span></li>
<li>joint3→endpoint→translation設(0.6,0,-0.1)，此為轉軸3的座標，z軸降低0.1m與base相接。</li>
<li><span>rotation設為(0,0,-1,2.37)。z軸為負且135.54°轉θ = 2.37 rad。</span></li>
<li>joint3<span>→endpoint→children<br/>新增第四個Hingejoint命名為joint4，</span><span><br/>新增第四個Pose命名為link3</span><span>。</span></li>
<li><span>joint4→endpoint新增SolidReference，solidName選擇預設值&lt;static environment&gt;。</span></li>
<li><span>補上在endpoint下所有的boundingObject，設為Pose，並在下方的children加上box，Pose座標為以上所有方塊所屬的Pose的座標。</span></li>
<li><span>每一階的HingeJoint下的jointparameters，每一階的axis旋轉方向都是z軸，因此設為(0,0,1)，並更改每一階的anchor：<br/>joint1的為(-0.5,0,0)<br/>joint2的為(0.4,0,0)<br/>joint3的為(0.6,0,0)<br/>joint4的為(0.9,0,0)。</span></li>
<li><span>link1、link2-1、link2-2、link3要加入物理碰撞physics使用預設值，由Webots自行運算即可。</span></li>
<li><span>加入controller選擇檔案。</span></li>
<li><span>存檔後時間歸零確認無誤，即可模擬。</span></li>
</ol>
<p><img alt="" height="525" src="/images/solvespace機構圖.jpg" width="600"/></p>
<p>操作影片標題：<span style="background-color: #ffff00;">國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam1 - 41023218</span></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/9sOgTnlI28I?si=hOr4qzvcdrBVmqWz" title="YouTube video player" width="560"></iframe></p>
<p>心得：</p>
<p>做到link2的時候，一開始腦袋轉不過來，抱著嘗試2個Pose的態度，嘗試過後成功了。</p><h2>Exam2</h2>
<p>Exam2 (10%)：利用 CAD 零組件建立模擬場景</p>
<p>操作影片標題：<span style="background-color: #ffff00;">國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam1 - 41023218</span></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/7jRTlb_-sUI?si=QCNSXQ1OVfLsO1DL" title="YouTube video player" width="560"></iframe></p><h2>Exam3</h2>
<p>Exam3 (20%)：Webots 機電模擬場景的協同設計</p>
<ol>
<li>
<p><span>操作影片標題：<span style="background-color: #ffff00;">國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam3-1 - 41023218</span></span></p>
<p>1.以 <span style="color: #0000ff;">webotsw --stream</span> 啟動。可以從<span style="background-color: #cceeff;">Console - all控制台</span>看到連接埠號：1235。<br/>2. 更改個人 IPv6 網址：<span style="color: #0000ff;">2001:288:6004:17:fff1:cd25:0000:b009</span>，並關閉 IPv4。<br/>3.Webots Streaming Viewer網址：<span style="color: #0000ff;">http://[2001:288:6004:17:fff1:cd25:0000:b009]:1235/index.html</span><br/> Connect to：<span style="color: #0000ff;">ws://[2001:288:6004:17:fff1:cd25:0000:b009]:1235</span><br/> 即可完成連線。<br/>4.若要連線到其他組員，修改Connect to到對方網址即可<br/>Connect to：<span style="color: #0000ff;">ws://[2001:288:6004:17:fff1:cd25:0000:b010]:1234</span></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/36GzrWxhasE?si=Mu3gYiVkD7YV6hdE" title="YouTube video player" width="560"></iframe></p>
</li>
<li>
<p>操作影片標題：<span style="background-color: #ffff00;">國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam3-2 - 41023218</span></p>
<p>1.以 <span style="color: #0000ff;">webotsw --stream</span> 啟動。<br/>2.開啟seven_segment.py。<br/>3.修改第85行顯示數字 number = 123 改成 number = 218。<br/>4.修改後存檔，並模擬結果。<br/>5.可以從<span style="background-color: #cceeff;">Console - all控制台</span>看到連接埠號：1235。<br/>6.更改個人 IPv6 網址：<span style="color: #0000ff;">2001:288:6004:17:fff1:cd25:0000:b009</span>，並關閉 IPv4。<br/>7.Webots Streaming Viewer網址：<span style="color: #0000ff;">http://[2001:288:6004:17:fff1:cd25:0000:b009]:1235/index.html</span><br/> Connect to：<span style="color: #0000ff;">ws://[2001:288:6004:17:fff1:cd25:0000:b009]:1235</span><br/> 即可完成連線。<br/>8.若要連線到其他組員，修改Connect to到對方網址即可<br/>Connect to：<span style="color: #0000ff;">ws://[2001:288:6004:17:fff1:cd25:0000:b010]:1234</span></p>
<p><iframe allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen="allowfullscreen" frameborder="0" height="315" referrerpolicy="strict-origin-when-cross-origin" src="https://www.youtube.com/embed/WCVBxRNdd1o?si=cRkrqZN6H3JDN25e" title="YouTube video player" width="560"></iframe></p>
</li>
<li>
<p>操作影片標題：<span style="background-color: #ffff00;">國立虎尾科技大學 - 機械設計工程系 - cd2025 Exam3-3 - 41023218</span></p>
<p>pip install websocket-client websocket-server keyboard</p>
</li>
</ol><h1>Final</h1>
<p><span>期末協同專案執行過程影片、簡報與 PDf 報告檔案 (六人一組) (30%)</span></p>
<p><span>題目: <span style="background-color: #ccffcc;">Webots 動態投籃模擬系統的協同設計</span></span></p>
<p><span>說明: </span></p>
<p style="padding-left: 30px;"><span>籃框架被配置在一定範圍內, 可隨機慢速前進、後退及左右擺動, 投籃機構系統帶有一定數量的籃球, 被配置在可自由移動的輪車上.</span></p>
<p style="padding-left: 30px;"><span>操作者可利用鍵盤特定按鍵控制投籃輪車的移動並發射投籃, 每投出一球後系統透過記分板進行計分, 並由送球機構進行補球或移動輪車取球, 遊戲可進行至全部數量籃球投完為止.</span></p>
<p>請將期末協同專案執行過程、內容與心得, 製作成影片，配合字幕上傳至 Youtube 後嵌入各階段的期末報告頁面中.</p>
<p>影片標題: <span style="background-color: #ffff00;">國立虎尾科技大學 - 機械設計工程系 - cd2025 期末報告 - 學員學號 - 各階段影片主題<br/></span></p>
<h1>Brython</h1>
<p><button id="add1to100">1 add to 100</button></p>
<!-- 導入 brython 程式庫 -->
<p>
<script src="/static/brython.js"></script>
<script src="/static/brython_stdlib.js"></script>
</p>
<!-- 啟動 Brython -->
<p>
<script>
window.onload=function(){
brython({debug:1, pythonpath:['/static/','./../downloads/py/']});
}
</script>
</p>
<p><!-- 導入 FileSaver 與 filereader --></p>
<p>
<script src="/static/ace/FileSaver.min.js" type="text/javascript"></script>
<script src="/static/ace/filereader.js" type="text/javascript"></script>
</p>
<p><!-- 導入 ace --></p>
<p>
<script src="/static/ace/ace.js" type="text/javascript"></script>
<script src="/static/ace/ext-language_tools.js" type="text/javascript"></script>
<script src="/static/ace/mode-python3.js" type="text/javascript"></script>
<script src="/static/ace/snippets/python.js" type="text/javascript"></script>
</p>
<p><!-- 導入 gearUtils-0.9.js Cango 齒輪繪圖程式庫 -->
<script src="/static/Cango-24v03-min.js"></script>
<script src="/static/gearUtils-09.js"></script>
<script src="/static/SVGpathUtils-6v03-min.js"></script>
<script src="/static/sylvester.js"></script>
<script src="/static/PrairieDraw.js"></script>
</p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src1"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/javascript">
function doSave(storage_id, filename){
    var blob = new Blob([localStorage[storage_id]], {type: "text/plain;charset=utf-8"});
    filename = document.getElementById(filename).value
    saveAs(blob, filename+".py");
}
</script>
</p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()
Ace1 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run1():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c3a6deaf717f8f2739a4b1392a5ab10936e9693a/from_1_add_to_10_1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace1.editor.setValue(prog)
    Ace1.editor.scrollToRow(0)
    Ace1.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace1.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run1'].bind('click', Ace1.run)
doc['kw_show_console1'].bind('click', Ace1.show_console)
doc['kw_clear_console1'].bind('click', Ace1.clear_console)
doc['clear_bd1'].bind('click', clear_bd1)
# 呼叫函式執行
run1()
</script>
</p>
<p><!-- add 1 to 100 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd1(ev):
    bd = doc["brython_div1"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace2 = ace.Editor(editor_id="kw_editor1", console_id="kw_console1", container_id="kw__container1", storage_id="kw_py_src1" )

add1to100_url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add(ev):
    Ace2.editor.setValue(add_src)
    Ace2.editor.scrollToRow(0)
    Ace2.editor.gotoLine(0)
    Ace2.run()

# id 為 "add1to100" 的按鈕點按時, 執行 add 方法
doc["add1to100"].bind('click', add)
</script>
</p>
<p><!-- add 1 to 100 結束--></p>
<!-- editor1 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor1" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src1', 'kw_filename1');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run1">Run</button> <button id="kw_show_console1">Output</button> <button id="kw_clear_console1">清除輸出區</button><button id="clear_bd1">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console1"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div1"></div>
<!-- editor1 結束 --><hr/><!-- ########################################## -->
<p>從 1 累加到 100 part2:</p>
<p><button id="add1to100part2">1 add to 100</button><button id="cango_three_gears">cango_three_gears</button><button id="bsnake">BSnake</button><button id="aitetris">AI Tetris</button></p>
<p><!-- 請注意, 這裡使用 Javascript 將 localStorage["kw_py_src2"] 中存在近端瀏覽器的程式碼, 由使用者決定存檔名稱--></p>
<p>
<script type="text/python3">
from browser import document as doc
import ace
# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()
Ace3 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )
# 從 gist 取出程式碼後, 放入 editor 作為 default 程式
def run2():
    # 利用 get 取下 src 變數值
    try:
        url = doc.query["src2"]
    except:
        url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c3a6deaf717f8f2739a4b1392a5ab10936e9693a/from_1_add_to_10_1.py"
    prog = open(url).read()

    # 將程式載入編輯區
    Ace3.editor.setValue(prog)
    Ace3.editor.scrollToRow(0)
    Ace3.editor.gotoLine(0)
    # 直接執行程式
    #ns = {'__name__':'__main__'}
    #exec(prog, ns)
    # 按下 run 按鈕
    Ace3.run()

# 執行程式, 顯示輸出結果與清除輸出結果及對應按鈕綁定
doc['kw_run2'].bind('click', Ace3.run)
doc['kw_show_console2'].bind('click', Ace3.show_console)
doc['kw_clear_console2'].bind('click', Ace3.clear_console)
doc['clear_bd2'].bind('click', clear_bd2)
# 呼叫函式執行
run2()
</script>
</p>
<p><!-- add 1 to 100 part2 開始 -->
<script type="text/python3">
from browser import document as doc
import ace

# 清除畫布
def clear_bd2(ev):
    bd = doc["brython_div2"]
    bd.clear()

# 利用 ace 中的 Editor 建立 Ace2 物件, 其中的輸入變數分別對應到頁面中的編輯區物件
Ace4 = ace.Editor(editor_id="kw_editor2", console_id="kw_console2", container_id="kw__container2", storage_id="kw_py_src2" )

# 透過 Ace4 以類別建立一個通用的 button2, 可以在多個案例中將 gist 程導入編輯區

class button2:
    def __init__(self, url):
        self.url = url

    # 記得加入 event 輸入變數
    def do(self,ev):
        Ace4.editor.setValue(open(self.url).read())
        Ace4.editor.scrollToRow(0)
        Ace4.editor.gotoLine(0)
        Ace4.run()

add1to100_url = "https://gist.githubusercontent.com/mdecourse/0229a8a017091476a79700b8a190f185/raw/c48e37714f055c3a0027cbfef59e442a6ef659b9/from_1_add_to_100_1.py"

# 從 gist 取得程式碼
add_src = open(add1to100_url).read()
def add2(ev):
    Ace4.editor.setValue(add_src)
    Ace4.editor.scrollToRow(0)
    Ace4.editor.gotoLine(0)
    Ace4.run()

# id 為 "add1to100part2" 的按鈕點按時, 執行 add 方法
doc["add1to100part2"].bind('click', add2)
# 以下為運用 button2 class 的通用 gist 程式導入區
################################## cango_three_gears start
cango_three_gears_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/cango_three_gears_brython_div2.py"
cango_three_gears = button2(cango_three_gears_url)
doc["cango_three_gears"].bind("click", cango_three_gears.do)
################################## cango_three_gears end
################################## bsnake start
bsnake_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/kmol_snakey.py"
bsnake = button2(bsnake_url)
doc["bsnake"].bind("click", bsnake.do)
################################## bsnake end
################################## aitetris start
aitetris_url = "https://gist.githubusercontent.com/mdecycu/d9082d678096bd58378d6afe2c7fa05d/raw/f7a85d737d6723d5e34c526d5daee990ed92c32b/pygame_to_brython_tetris_ai.py"
aitetris = button2(aitetris_url)
doc["aitetris"].bind("click", aitetris.do)
################################## aitetris end
</script>
</p>
<p><!-- add 1 to 100 part2 結束--></p>
<!-- editor2 開始 -->
<p><!-- 用來顯示程式碼的 editor 區域 --></p>
<div id="kw_editor2" style="width: 600px; height: 300px;"></div>
<p><!-- 以下的表單與按鈕與前面的 Javascript doSave 函式以及 FileSaver.min.js 互相配合 --></p>
<p><!-- 存擋表單開始 --></p>
<form><label>Filename: <input id="kw_filename2" placeholder="input file name" type="text"/>.py</label> <input onclick="doSave('kw_py_src2', 'kw_filename2');" type="submit" value="Save"/></form>
<p><!-- 存擋表單結束 --></p>
<p></p>
<p><!-- 執行與清除按鈕開始 --></p>
<p><button id="kw_run2">Run</button> <button id="kw_show_console2">Output</button> <button id="kw_clear_console2">清除輸出區</button><button id="clear_bd2">清除繪圖區</button><button onclick="window.location.reload()">Reload</button></p>
<p><!-- 執行與清除按鈕結束 --></p>
<p></p>
<p><!-- 程式執行 ouput 區 --></p>
<div style="width: 100%; height: 100%;"><textarea autocomplete="off" id="kw_console2"></textarea></div>
<p><!-- Brython 程式執行的結果, 都以 brython_div1 作為切入位置 --></p>
<div id="brython_div2"></div>
<!-- editor2 結束 --><hr/>
<p>
<script src="https://unpkg.com/three@0.144.0/build/three.js" type="text/javascript"></script>
</p>